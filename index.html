<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TogetherTime</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212;
            color: #E0E0E0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }

        .container {
            background-color: #1E1E1E;
            padding: 2.5rem;
            border-radius: 1rem;
            max-width: 900px;
            width: 100%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header .invite-button {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            background-color: #4CAF50;
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .header .invite-button:hover {
            transform: translateY(-2px);
            background-color: #66BB6A;
        }

        .video-container {
            position: relative;
            background-color: black;
            border-radius: 0.75rem;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
        }

        .video-player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .remote-video {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        .local-video-file-player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: black;
            z-index: 5;
            display: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .control-button {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .share-screen {
            background-color: #03A9F4;
            color: white;
            box-shadow: 0 4px 15px rgba(3, 169, 244, 0.4);
        }
        
        .share-screen:hover {
            transform: translateY(-2px);
            background-color: #29B6F6;
        }

        .toggle-mic {
            background-color: #F44336;
            color: white;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }
        
        .toggle-mic:hover {
            transform: translateY(-2px);
            background-color: #E57373;
        }

        .local-video-button {
            background-color: #9C27B0;
            color: white;
            box-shadow: 0 4px 15px rgba(156, 39, 176, 0.4);
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        
        .local-video-button:hover {
            transform: translateY(-2px);
            background-color: #AB47BC;
        }
        
        .local-video-button input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* Live-stream chat styles */
        .chat-box {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background-color: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(5px);
            border-radius: 0.75rem;
            padding: 1rem;
        }

        .chat-messages {
            max-height: 120px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .chat-message {
            background-color: rgba(51, 51, 51, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            word-wrap: break-word;
            opacity: 1;
            transition: opacity 2s ease-out;
        }
        
        .chat-message.fade-out {
            opacity: 0;
        }

        .chat-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border-radius: 9999px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
        }

        .chat-send-button {
            padding: 0.75rem;
            border-radius: 9999px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .chat-send-button:hover {
            background-color: #66BB6A;
        }
        
        .message-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #2A2A2A;
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .modal-button {
            padding: 0.75rem 1.5rem;
            background-color: #4CAF50;
            color: white;
            border-radius: 9999px;
            cursor: pointer;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .header {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
    <!-- Firebase Libraries -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, collection, query, addDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('debug');

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Hardcoded Firebase configuration from your project
        const firebaseConfig = {
            apiKey: "AIzaSyCKPARNHk-6Jyl_tJpDrX_taqyktqeSA9s",
            authDomain: "my-watch-party-app.firebaseapp.com",
            projectId: "my-watch-party-app",
            storageBucket: "my-watch-party-app.firebasestorage.app",
            messagingSenderId: "72645236319",
            appId: "1:72645236319:web:98959a0f51575902726dea"
        };
        

        let app;
        let db;
        let auth;
        let userId = null;
        let isHost = false;
        let isAuthReady = false;
        const mainChannelDocId = 'main-channel';
        const messagesCollectionName = 'chat_messages';
        const signalingCollectionName = 'signaling';
        let pc = null; // RTCPeerConnection object
        let localScreenStream = null;
        let localAudioStream = null;
        let isLocalVideoPlaying = false;

        // Get the DOM elements
        const videoElement = document.getElementById('video-player');
        const remoteVideo = document.getElementById('remote-video');
        const remoteAudio = document.getElementById('remote-audio');
        const localVideoFilePlayer = document.getElementById('local-video-file-player');
        const videoFileInput = document.getElementById('video-file-input');
        const shareScreenBtn = document.getElementById('share-screen-btn');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const inviteBtn = document.getElementById('invite-btn');
        const authStatus = document.getElementById('auth-status');
        const userIdDisplay = document.getElementById('user-id');
        const messageModal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');

        // Function to show a custom modal message
        function showMessage(message) {
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }

        // Close modal
        modalOkBtn.onclick = () => {
            messageModal.style.display = 'none';
        };

        // --- Firebase Initialization and Authentication ---
        async function setupFirebase() {
            if (!firebaseConfig) {
                showMessage('Firebase configuration is missing. Please ensure the app is configured with Firebase.');
                return;
            }

            console.log("Using Firebase config:", firebaseConfig);

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                authStatus.textContent = 'Auth initializing...';
                
                // Attempt to sign in with the custom token if it exists.
                // If it fails, or if the token is not present, sign in anonymously.
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("Signed in with custom token successfully.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously.");
                    }
                } catch (e) {
                    // This specific error (auth/custom-token-mismatch) is expected in some environments.
                    // We will silently fall back to anonymous sign-in to ensure functionality.
                    if (e.code === 'auth/custom-token-mismatch') {
                        console.log("Custom token mismatch detected. Falling back to anonymous sign-in.");
                    } else {
                        console.error("Custom token sign-in failed. Falling back to anonymous sign-in.", e);
                    }
                    await signInAnonymously(auth);
                }

                // The onAuthStateChanged listener handles the UI updates after sign-in completes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        authStatus.textContent = 'Auth successful!';
                        userIdDisplay.textContent = `User ID: ${userId}`;
                        isAuthReady = true;
                        await checkAndSetupHost();
                        listenForChatMessages();
                    } else {
                        // User is signed out. UI will reflect this.
                        console.log("User is signed out.");
                        authStatus.textContent = 'Auth failed or anonymous.';
                        userIdDisplay.textContent = 'User ID: Anonymous';
                        isAuthReady = true; // Still allow app functions for anonymous user.
                    }
                });
            } catch (error) {
                console.error("Firebase setup failed:", error);
                authStatus.textContent = 'Auth Error: See console for details.';
                showMessage(`Firebase setup failed: ${error.message}`);
            }
        }

        async function checkAndSetupHost() {
            if (!db || !isAuthReady) {
                console.warn("Firestore not ready. Aborting checkAndSetupHost.");
                return;
            }
            try {
                const docRef = doc(db, `artifacts/${appId}/public/data/${signalingCollectionName}`, mainChannelDocId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists() && docSnap.data().hostId) {
                    isHost = false;
                    shareScreenBtn.textContent = 'Watching Live';
                    shareScreenBtn.disabled = true;
                    showMessage("A watch party is already active. You are a viewer.");
                    // Viewer logic
                    setupPeerConnection();
                    listenForSignaling(docRef);
                } else {
                    isHost = true;
                    shareScreenBtn.textContent = 'Become Host & Share Screen';
                    shareScreenBtn.disabled = false;
                }
            } catch (e) {
                console.error("Error getting document:", e);
                showMessage("Failed to connect to the server. Please check your internet connection.");
            }
        }

        // --- WebRTC Logic ---
        const servers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
            ]
        };

        function setupPeerConnection() {
            if (pc) return; // Only set up once
            pc = new RTCPeerConnection(servers);
            
            // Listen for remote tracks and attach them to the video/audio elements
            pc.ontrack = (event) => {
                if (event.track.kind === 'video') {
                    const videoStream = new MediaStream([event.track]);
                    remoteVideo.srcObject = videoStream;
                    videoElement.style.display = 'none';
                    localVideoFilePlayer.style.display = 'none';
                    remoteVideo.style.display = 'block';
                    showMessage("Connected to host. Screen sharing is live.");
                } else if (event.track.kind === 'audio') {
                    const audioStream = new MediaStream([event.track]);
                    remoteAudio.srcObject = audioStream;
                }
            };
        }

        async function createHostOffer() {
            if (!isAuthReady) {
                showMessage("Firebase is not configured for a live session. Screen sharing and chat are disabled. Please use the hosted link.");
                return;
            }
            try {
                // Determine which stream to capture based on what's playing
                let stream;
                if (isLocalVideoPlaying && localVideoFilePlayer.srcObject) {
                    stream = localVideoFilePlayer.captureStream();
                    localScreenStream = stream;
                    showMessage("Sharing local video file. Waiting for a viewer to connect...");
                } else {
                    stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                    localScreenStream = stream;
                    videoElement.srcObject = stream;
                    videoElement.style.display = 'block';
                    localVideoFilePlayer.style.display = 'none';
                    remoteVideo.style.display = 'none';
                    showMessage("Screen capture started. Waiting for a viewer to connect...");
                }

                setupPeerConnection();
                stream.getTracks().forEach(track => pc.addTrack(track, stream));

                const docRef = doc(db, `artifacts/${appId}/public/data/${signalingCollectionName}`, mainChannelDocId);
                
                // Collect ICE candidates and send to Firestore
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        setDoc(doc(docRef, 'iceCandidates', event.candidate.sdpMid), { candidate: event.candidate.toJSON() }, { merge: true });
                    }
                };
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                await setDoc(docRef, {
                    hostId: userId,
                    offer: {
                        type: offer.type,
                        sdp: offer.sdp
                    },
                    createdAt: Date.now()
                });
                
                // Listen for viewer's answer
                onSnapshot(docRef, async (docSnap) => {
                    const data = docSnap.data();
                    if (data?.answer) {
                        try {
                            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                            showMessage("Viewer connected successfully!");
                            // Clean up answer once connected
                            await updateDoc(docRef, { answer: null });
                            // Now listen for viewer's ICE candidates
                            onSnapshot(collection(docRef, 'iceCandidates'), (snapshot) => {
                                snapshot.docChanges().forEach(change => {
                                    if (change.type === "added") {
                                        const candidate = new RTCIceCandidate(change.doc.data().candidate);
                                        pc.addIceCandidate(candidate);
                                    }
                                });
                            });
                        } catch(e) {
                             console.error("Error setting remote description for host:", e);
                        }
                    }
                });
            } catch (error) {
                console.error("Error creating host offer:", error);
                shareScreenBtn.textContent = 'Become Host & Share Screen';
                shareScreenBtn.disabled = false;
                showMessage("Failed to share screen. Please ensure you allow permissions.");
            }
        }

        async function listenForSignaling(docRef) {
            if (!isAuthReady) {
                return;
            }
            onSnapshot(docRef, async (docSnap) => {
                if (docSnap.exists() && docSnap.data().offer && !isHost) {
                    const data = docSnap.data();
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await updateDoc(docRef, {
                        answer: {
                            type: answer.type,
                            sdp: answer.sdp
                        }
                    });

                    // Collect ICE candidates and send to Firestore
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            setDoc(doc(docRef, 'iceCandidates', event.candidate.sdpMid), { candidate: event.candidate.toJSON() }, { merge: true });
                        }
                    };
                }
            });
        }

        // --- Microphone Logic ---
        async function toggleMic() {
            if (!isAuthReady) {
                showMessage("This feature is disabled. Please use the hosted link for full functionality.");
                return;
            }

            setupPeerConnection(); // Ensure peer connection is set up

            if (localAudioStream) {
                // Mic is on, turn it off
                localAudioStream.getTracks().forEach(track => {
                    pc.removeTrack(pc.getSenders().find(sender => sender.track === track));
                    track.stop();
                });
                localAudioStream = null;
                toggleMicBtn.textContent = 'Turn Mic On';
                showMessage("Microphone turned off.");
            } else {
                // Mic is off, turn it on
                try {
                    localAudioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    localAudioStream.getTracks().forEach(track => pc.addTrack(track, localAudioStream));
                    toggleMicBtn.textContent = 'Turn Mic Off';
                    showMessage("Microphone turned on.");
                } catch (error) {
                    console.error("Error getting audio stream:", error);
                    showMessage("Could not access microphone. Please check your browser permissions.");
                }
            }
        }

        // --- Local Video Logic ---
        videoFileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('video/')) {
                const videoURL = URL.createObjectURL(file);
                localVideoFilePlayer.src = videoURL;
                localVideoFilePlayer.style.display = 'block';
                videoElement.style.display = 'none';
                remoteVideo.style.display = 'none';
                isLocalVideoPlaying = true;
                shareScreenBtn.textContent = 'Share Video';
                showMessage("Video loaded. Click 'Share Video' to stream it.");
                localVideoFilePlayer.play();
            } else {
                showMessage("Please select a valid video file.");
                localVideoFilePlayer.style.display = 'none';
                isLocalVideoPlaying = false;
                shareScreenBtn.textContent = 'Become Host & Share Screen';
            }
        };

        // --- Chat Logic ---
        function listenForChatMessages() {
            if (!db || !isAuthReady) {
                return;
            }
            const q = query(collection(db, `artifacts/${appId}/public/data/${messagesCollectionName}`));

            // Listen only for new messages being added
            onSnapshot(q, (querySnapshot) => {
                querySnapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const msg = change.doc.data();
                        const messageEl = document.createElement('div');
                        messageEl.classList.add('chat-message');
                        messageEl.textContent = `${msg.userId.substring(0, 4)}: ${msg.message}`;
                        chatMessages.appendChild(messageEl);

                        // Auto-scroll to the bottom for new messages
                        chatMessages.scrollTop = chatMessages.scrollHeight;

                        // Set a timer to start the fade-out process after a delay
                        setTimeout(() => {
                            messageEl.classList.add('fade-out');
                            // Remove the element from the DOM after the transition is complete
                            setTimeout(() => messageEl.remove(), 2000); // Wait for the 2s transition
                        }, 10000); // 10 seconds before starting to fade out
                    }
                });
            });
        }
        
        chatSendBtn.onclick = async () => {
            const message = chatInput.value.trim();
            if (!message || !isAuthReady) {
                showMessage("Chat is disabled. Please use the hosted link for live chat.");
                return;
            }

            try {
                await addDoc(collection(db, `artifacts/${appId}/public/data/${messagesCollectionName}`), {
                    userId: userId,
                    message: message,
                    timestamp: Date.now(),
                });
                chatInput.value = '';
            } catch (e) {
                console.error("Error sending message: ", e);
                showMessage("Failed to send message.");
            }
        };
        
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                chatSendBtn.click();
            }
        });

        // --- Event Handlers ---
        shareScreenBtn.onclick = () => {
            if (!isAuthReady) {
                showMessage("This feature is disabled. Please use the hosted link for full functionality.");
                return;
            }
            isHost = true;
            shareScreenBtn.textContent = 'You are the Host';
            shareScreenBtn.disabled = true;
            createHostOffer();
        };

        toggleMicBtn.onclick = toggleMic;

        inviteBtn.onclick = () => {
            const url = window.location.href;
            navigator.clipboard.writeText(url).then(() => {
                modalMessage.textContent = 'Link copied to clipboard! Share it with your friends.';
                messageModal.style.display = 'flex';
            }).catch(err => {
                showMessage('Failed to copy the link. Please copy the URL from your browser address bar.');
                console.error('Copy failed:', err);
            });
        };
        
        // Initial setup
        window.onload = setupFirebase;
    </script>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="container">
        <div class="header">
            <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">TogetherTime</h1>
            <div class="flex items-center gap-4">
                <span id="auth-status" class="text-xs text-gray-400">Loading...</span>
                <span id="user-id" class="text-xs text-gray-400"></span>
                <button id="invite-btn" class="invite-button">Invite</button>
            </div>
        </div>

        <div class="video-container">
            <!-- These are for streaming/remote content -->
            <video id="video-player" class="video-player hidden" autoplay playsinline muted></video>
            <video id="remote-video" class="remote-video" autoplay playsinline></video>
            <audio id="remote-audio" autoplay playsinline></audio>
            
            <!-- This is for playing a local video file -->
            <video id="local-video-file-player" class="local-video-file-player" autoplay loop muted></video>
            
            <!-- Chat box now overlays the video -->
            <div class="chat-box">
                <div id="chat-messages" class="chat-messages"></div>
                <div class="chat-input-container">
                    <input id="chat-input" type="text" placeholder="Type a message..." class="chat-input">
                    <button id="chat-send-btn" class="chat-send-button">Send</button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="share-screen-btn" class="control-button share-screen">Become Host & Share Screen</button>
            <button id="toggle-mic-btn" class="control-button toggle-mic">Turn Mic On</button>
            <label class="control-button local-video-button">
                Choose Video File
                <input type="file" id="video-file-input" accept="video/*">
            </label>
        </div>

    </div>
    
    <!-- Custom Message Modal -->
    <div id="message-modal" class="message-modal hidden">
        <div class="modal-content">
            <p id="modal-message" class="text-lg"></p>
            <button id="modal-ok-btn" class="modal-button">OK</button>
        </div>
    </div>

</body>
</html>
