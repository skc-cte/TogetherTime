<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TogetherTime</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212;
            color: #e0e0e0;
        }
        .container {
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .video-container {
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #000;
        }
        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 50vh;
            background-color: #1c1c1c;
            border-top-left-radius: 1.5rem;
            border-top-right-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
        }
        .chat-box {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-bottom: 1rem;
        }
        .message-row {
            display: flex;
            align-items: center;
        }
        .my-message {
            margin-left: auto;
            background-color: #3b82f6;
            color: white;
            border-radius: 1.5rem 1.5rem 0.25rem 1.5rem;
            padding: 0.5rem 1rem;
        }
        .other-message {
            background-color: #2e2e2e;
            color: #e0e0e0;
            border-radius: 1.5rem 1.5rem 1.5rem 0.25rem;
            padding: 0.5rem 1rem;
        }
        .input-area {
            display: flex;
            gap: 0.5rem;
        }
        .input-area input {
            flex-grow: 1;
            border: none;
            outline: none;
            padding: 0.75rem 1.25rem;
            background-color: #2e2e2e;
            border-radius: 9999px;
            color: #e0e0e0;
        }
        .input-area button {
            background-color: #3b82f6;
            color: white;
            border-radius: 9999px;
            padding: 0.75rem 1.25rem;
            transition: background-color 0.2s;
        }
        .input-area button:hover {
            background-color: #2563eb;
        }
        .header {
            background-color: #1c1c1c;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom-left-radius: 1.5rem;
            border-bottom-right-radius: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .control-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .control-buttons button {
            background-color: #2e2e2e;
            color: #e0e0e0;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans flex flex-col items-center">

    <!-- Firebase SDK Scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // This is the correct firebaseConfig provided by the user
        const firebaseConfig = {
            apiKey: "AIzaSyCKPARNHk-6Jyl_tJpDrX_taqyktqeSA9s",
            authDomain: "my-watch-party-app.firebaseapp.com",
            projectId: "my-watch-party-app",
            storageBucket: "my-watch-party-app.firebasestorage.app",
            messagingSenderId: "72645236319",
            appId: "1:72645236319:web:98959a0f51575902726dea",
            measurementId: "G-VLQM5PG4WG"
        };
        
        // Add console logs for debugging purposes
        console.log("Firebase config:", firebaseConfig);

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Firestore constants and WebRTC config
        const ICE_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
            ],
        };

        // State for the user and app
        let currentUser = null;
        let userId = null;
        let partyId = null;
        let peerConnection = null;
        let localScreenStream = null;
        let localMicStream = null;
        let micEnabled = false;
        let isAuthReady = false;

        // UI Elements
        let chatBox;
        let messageInput;
        let sendButton;
        let partyIdDisplay;
        let copyButton;
        let videoPlayer;
        let inviteButton;
        let shareButton;
        let stopShareButton;
        let micButton;
        let localVideoInput;
        
        // Firestore Collection References (will be set in initApp)
        let chatCollectionRef = null;
        let signalingCollectionRef = null;
        let videoStateDocRef = null;
        let isSyncing = false; // Flag to prevent feedback loop

        // Function to handle authentication and app initialization
        async function initApp() {
            // Assign UI elements after the DOM is fully loaded
            chatBox = document.getElementById('chat-box');
            messageInput = document.getElementById('message-input');
            sendButton = document.getElementById('send-button');
            partyIdDisplay = document.getElementById('party-id-display');
            copyButton = document.getElementById('copy-button');
            videoPlayer = document.getElementById('video-player');
            inviteButton = document.getElementById('invite-button');
            shareButton = document.getElementById('share-screen-button');
            stopShareButton = document.getElementById('stop-sharing-button');
            micButton = document.getElementById('mic-button');
            localVideoInput = document.getElementById('local-video-input');
            
            try {
                // Try anonymous sign-in first, as it's the simplest method for this app.
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Firebase Auth Error:", error);
                // Check for the specific error and provide more detail to the user
                let errorMessage = 'An authentication error occurred. Please check the console for more details.';
                if (error.code === 'auth/configuration-not-found') {
                    errorMessage = 'Auth Error: `auth/configuration-not-found`. The Firebase project may not have any sign-in methods enabled (e.g., Anonymous). Please check your Firebase Console.';
                } else if (error.code === 'auth/invalid-custom-token') {
                    errorMessage = 'Auth Error: Invalid custom token. Please make sure your token is correct.';
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = 'Auth Error: Network issue. Please check your internet connection.';
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = 'Auth Error: Anonymous sign-in is not enabled in your Firebase project. Please enable it in the Authentication settings.';
                } else {
                    errorMessage = `Auth Error: ${error.message}`;
                }
                partyIdDisplay.textContent = errorMessage;
                showMessageBox(errorMessage);
                return; // Stop app initialization on auth failure
            }

            // Listen for auth state changes to ensure Firebase is ready
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    userId = user.uid;
                    isAuthReady = true;

                    const urlParams = new URLSearchParams(window.location.search);
                    partyId = urlParams.get('partyId') || userId;
                    
                    partyIdDisplay.textContent = `Party ID: ${partyId.substring(0, 8)}...`;
                    console.log("Authentication successful! User ID:", userId);
                    console.log("Joined Party ID:", partyId);

                    // Set up Firestore collection references based on the party ID
                    chatCollectionRef = collection(db, `/artifacts/${appId}/public/data/parties/${partyId}/chat_messages`);
                    signalingCollectionRef = collection(db, `/artifacts/${appId}/public/data/parties/${partyId}/signaling`);
                    videoStateDocRef = doc(db, `artifacts/${appId}/public/data/parties/${partyId}/video_state/state`);

                    // Start listening to chat messages and video state
                    setupChatListener();
                    setupVideoSyncListener();
                    setupSignalingListener();
                    setupVideoEventListeners();
                    setupButtonListeners();
                } else {
                    // User is signed out
                    isAuthReady = false;
                    userId = null;
                    partyIdDisplay.textContent = 'Signed Out';
                }
            });
        }
        
        // New function to handle all button listeners
        function setupButtonListeners() {
            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            copyButton.addEventListener('click', inviteUser);
            inviteButton.addEventListener('click', inviteUser);
            shareButton.addEventListener('click', startScreenShare);
            stopShareButton.addEventListener('click', stopSharing);
            micButton.addEventListener('click', toggleMic);
            localVideoInput.addEventListener('change', loadLocalVideo);
        }

        // Function to setup the Firestore real-time listener for chat messages
        function setupChatListener() {
            const q = query(chatCollectionRef);
            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const message = change.doc.data();
                    if (change.type === "added") {
                        addMessageToUI(message);
                    }
                });
                chatBox.scrollTop = chatBox.scrollHeight;
            }, (error) => {
                console.error("Error listening for chat messages: ", error);
            });
        }
        
        // Function to set up Firestore real-time listener for video state
        function setupVideoSyncListener() {
            onSnapshot(videoStateDocRef, (doc) => {
                if (doc.exists() && !isSyncing) {
                    const state = doc.data();
                    if (state.lastUpdatedBy !== userId) {
                        isSyncing = true;
                        if (state.isPlaying) {
                            videoPlayer.play();
                        } else {
                            videoPlayer.pause();
                        }
                        // Only update time if the difference is significant to avoid jitter
                        if (Math.abs(videoPlayer.currentTime - state.currentTime) > 1) {
                            videoPlayer.currentTime = state.currentTime;
                        }
                        isSyncing = false;
                    }
                }
            }, (error) => {
                console.error("Error listening for video state: ", error);
            });
        }
        
        // Function to add event listeners to the video player for syncing
        function setupVideoEventListeners() {
            videoPlayer.addEventListener('play', () => {
                if (!isSyncing) {
                    updateVideoState(true);
                }
            });
            videoPlayer.addEventListener('pause', () => {
                if (!isSyncing) {
                    updateVideoState(false);
                }
            });
            videoPlayer.addEventListener('seeked', () => {
                if (!isSyncing) {
                    updateVideoState(videoPlayer.paused === false);
                }
            });
        }
        
        // Function to update video state in Firestore
        async function updateVideoState(isPlaying) {
            try {
                await setDoc(videoStateDocRef, {
                    isPlaying: isPlaying,
                    currentTime: videoPlayer.currentTime,
                    lastUpdatedBy: userId,
                    timestamp: serverTimestamp()
                });
            } catch (error) {
                console.error("Error updating video state: ", error);
            }
        }

        // Function to setup Firestore real-time listener for WebRTC signaling
        function setupSignalingListener() {
            onSnapshot(signalingCollectionRef, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    const data = change.doc.data();
                    if (data.senderId === userId) return; // Ignore messages from self

                    if (data.type === 'offer') {
                        if (!peerConnection) createPeerConnection();
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        if (signalingCollectionRef) {
                            await addDoc(signalingCollectionRef, { type: answer.type, sdp: answer.sdp, senderId: userId });
                        }
                        console.log("Answer sent to Firestore.");
                    } else if (data.type === 'answer') {
                        if (peerConnection && peerConnection.signalingState !== 'stable') {
                             await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                             console.log("Received and set answer.");
                        } else {
                            console.log("Received answer but connection is not in a state to accept it.");
                        }
                    } else if (data.type === 'candidate') {
                        if (peerConnection) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                                console.log("Added ICE candidate.");
                            } catch (e) {
                                console.error("Error adding received ICE candidate:", e);
                            }
                        }
                    }
                });
            }, (error) => {
                console.error("Error listening for signaling messages: ", error);
            });
        }

        // Function to create a new RTCPeerConnection
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(ICE_SERVERS);
            
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate && signalingCollectionRef) {
                    await addDoc(signalingCollectionRef, {
                        type: 'candidate',
                        candidate: event.candidate.toJSON(),
                        senderId: userId
                    });
                }
            };
            
            peerConnection.ontrack = (event) => {
                console.log("Received a track!", event.track);
                if (event.track.kind === 'video') {
                    videoPlayer.srcObject = event.streams[0];
                    videoPlayer.controls = false; // Remote video should not have controls
                    showMessageBox("Screen share from a friend is now live!");
                }
            };
            
            peerConnection.onnegotiationneeded = async () => {
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    if (signalingCollectionRef) {
                        await addDoc(signalingCollectionRef, { type: offer.type, sdp: offer.sdp, senderId: userId });
                        console.log("Offer sent to Firestore.");
                    }
                } catch (e) {
                    console.error("Error creating and sending offer:", e);
                }
            };
        }

        // Function to start screen sharing
        async function startScreenShare() {
            if (!isAuthReady) {
                showMessageBox("Please wait, app is still initializing.");
                return;
            }
            try {
                // Get display media without audio to prevent conflicts with the separate mic stream
                localScreenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: false
                });

                videoPlayer.srcObject = localScreenStream;
                videoPlayer.controls = true;
                shareButton.style.display = 'none';
                stopShareButton.style.display = 'block';
                
                // Clear out existing tracks from a previous connection
                if (peerConnection) {
                    peerConnection.getSenders().forEach(sender => {
                        peerConnection.removeTrack(sender);
                    });
                }
                
                if (!peerConnection) createPeerConnection();
                localScreenStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localScreenStream);
                });

                // Listen for screen share stop event
                localScreenStream.getVideoTracks()[0].onended = () => {
                    stopSharing();
                };

                // Remove the old chat messages to start with a fresh screen
                chatBox.innerHTML = '<div class="text-center text-gray-400 py-2 text-sm">Screen sharing started!</div>';

            } catch (error) {
                console.error("Error starting screen share:", error);
                showMessageBox("Screen sharing failed. Please ensure you have granted permission.");
            }
        }
        
        // Function to stop screen sharing
        function stopSharing() {
            if (localScreenStream) {
                localScreenStream.getTracks().forEach(track => {
                    // Stop the track
                    track.stop();
                });
                localScreenStream = null;
            }
            
            // Remove video track from peer connection
            if (peerConnection) {
                peerConnection.getSenders().forEach(sender => {
                    if (sender.track && sender.track.kind === 'video') {
                        peerConnection.removeTrack(sender);
                    }
                });
            }
            
            // Revert video player to placeholder
            videoPlayer.srcObject = null;
            videoPlayer.src = "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4";
            videoPlayer.controls = true;
            
            shareButton.style.display = 'block';
            stopShareButton.style.display = 'none';
            showMessageBox("Screen sharing has ended.");
        }

        // Function to start the microphone stream and add it to the peer connection
        async function startMic() {
            if (!isAuthReady) {
                showMessageBox("Please wait, app is still initializing.");
                return;
            }
            try {
                localMicStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                if (!peerConnection) createPeerConnection();
                
                localMicStream.getAudioTracks().forEach(track => {
                    peerConnection.addTrack(track, localMicStream);
                });
                micEnabled = true;
                micButton.textContent = 'Mic On';
                micButton.classList.remove('bg-gray-600');
                micButton.classList.add('bg-green-600');
                showMessageBox("Microphone is now ON. Your friends in the party can hear you.");
            } catch (error) {
                console.error("Error getting microphone:", error);
                showMessageBox("Failed to access your microphone. Please check your browser permissions.");
            }
        }

        // Function to toggle microphone mute
        function toggleMic() {
            if (!localMicStream) {
                startMic();
                return;
            }
            micEnabled = !micEnabled;
            localMicStream.getAudioTracks().forEach(track => track.enabled = micEnabled);
            micButton.textContent = micEnabled ? "Mic On" : "Mic Off";
            const message = micEnabled ? "Your microphone is now ON." : "Your microphone is now OFF.";
            micButton.classList.toggle('bg-green-600', micEnabled);
            micButton.classList.toggle('bg-gray-600', !micEnabled);
            showMessageBox(message);
        }

        // Function to handle local video file selection
        function loadLocalVideo(event) {
            const file = event.target.files[0];
            if (file) {
                const videoURL = URL.createObjectURL(file);
                videoPlayer.src = videoURL;
                videoPlayer.load();
                videoPlayer.play();
                showMessageBox("Local video loaded. Use the 'Share Screen' button to share it with your friend.");
            }
        }

        // Function to send a new message
        async function sendMessage() {
            if (!isAuthReady) return;
            const messageText = messageInput.value.trim();
            if (messageText === '') return;

            try {
                await addDoc(chatCollectionRef, {
                    userId: userId,
                    text: messageText,
                    timestamp: serverTimestamp(),
                });
                messageInput.value = '';
            } catch (error) {
                console.error("Error sending message:", error);
            }
        }

        // Function to add a message to the UI
        function addMessageToUI(message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message-row');
            
            const isMyMessage = message.userId === userId;
            const messageBubble = document.createElement('div');
            messageBubble.textContent = message.text;
            
            if (isMyMessage) {
                messageBubble.classList.add('my-message');
                messageElement.classList.add('justify-end');
            } else {
                messageBubble.classList.add('other-message');
                messageElement.classList.add('justify-start');
                const senderName = document.createElement('span');
                senderName.textContent = `(${message.userId.substring(0, 4)}...): `;
                senderName.classList.add('text-xs', 'text-gray-400', 'pr-2');
                messageElement.appendChild(senderName);
            }
            
            messageElement.appendChild(messageBubble);
            chatBox.appendChild(messageElement);
        }
        
        // Function to handle invite logic
        function inviteUser() {
            let inviteUrl;
            // Check for local file protocol, which can result in 'null' origin
            if (window.location.origin === 'null') {
                // For local files, use the full href to include the file path
                inviteUrl = `${window.location.href}?partyId=${partyId}`;
            } else {
                // For a hosted website, use the standard origin
                inviteUrl = `${window.location.origin}${window.location.pathname}?partyId=${partyId}`;
            }

            navigator.clipboard.writeText(inviteUrl).then(() => {
                showMessageBox(`Invitation link copied to clipboard: <br><br><b>${inviteUrl}</b><br><br> Share it with your friend to join this party.`);
            }).catch(err => {
                showMessageBox('Could not copy invite link. Please copy it manually.');
                console.error('Failed to copy text: ', err);
            });
        }

        // Simple message box instead of alert
        function showMessageBox(message) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background-color: #2e2e2e; padding: 2rem; border-radius: 0.75rem;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); z-index: 1000;
                text-align: center; color: white; max-width: 80%;
            `;
            modal.innerHTML = `
                <p>${message}</p>
                <button onclick="this.parentNode.remove()" style="margin-top: 1rem; padding: 0.5rem 1.5rem; background-color: #3b82f6; border-radius: 9999px;">OK</button>
            `;
            document.body.appendChild(modal);
        }
        
        // Overwrite the default alert to use our custom message box
        window.alert = showMessageBox;


        // Start the app on window load
        window.onload = initApp;

    </script>

    <!-- App UI -->
    <div class="container flex flex-col h-screen overflow-hidden">
        
        <!-- Header with app name and invite button -->
        <div class="header">
            <h1 class="text-2xl font-bold text-blue-400">TogetherTime</h1>
            <div class="flex items-center gap-2">
                <span id="party-id-display" class="text-sm bg-gray-700 px-3 py-1 rounded-full truncate max-w-[150px]">Loading...</span>
                <button id="copy-button" class="bg-gray-700 p-2 rounded-full hover:bg-gray-600 transition-colors tooltip">
                    <span class="tooltiptext">Copy Invite Link</span>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                        <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2h-2.586a1 1 0 01-.707-.293l-1.414-1.414A1 1 0 009.586 1H6a1 1 0 00-1 1v1h1z" />
                        <path d="M12 5H8v10h4V5z" clip-rule="evenodd" fill-rule="evenodd" />
                    </svg>
                </button>
                <button id="invite-button" class="bg-blue-600 text-white font-medium px-4 py-2 rounded-full hover:bg-blue-500 transition-colors">Invite</button>
            </div>
        </div>

        <!-- Video Player Section -->
        <div class="flex-grow flex flex-col justify-center items-center">
            <div class="video-container w-full max-w-4xl rounded-lg overflow-hidden shadow-2xl">
                <video id="video-player" src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4" controls preload="auto">
                    Your browser does not support the video tag.
                </video>
            </div>
            <p class="mt-4 text-sm text-gray-400">Play, pause, and seek together! (Note: This is a placeholder video. In a real app, video playback would be synchronized.)</p>
            <div class="flex flex-col sm:flex-row gap-4 mt-4 items-center">
                <label for="local-video-input" class="cursor-pointer bg-gray-600 text-white font-medium px-4 py-2 rounded-full hover:bg-gray-500 transition-colors">
                    <input type="file" id="local-video-input" accept="video/*" class="hidden">
                    Load Local Video
                </label>
                <div class="flex gap-4">
                    <button id="share-screen-button" class="bg-green-600 text-white font-medium px-4 py-2 rounded-full hover:bg-green-500 transition-colors">Share Screen</button>
                    <button id="stop-sharing-button" class="bg-red-600 text-white font-medium px-4 py-2 rounded-full hover:bg-red-500 transition-colors" style="display:none;">Stop Sharing</button>
                    <button id="mic-button" class="bg-gray-600 text-white font-medium px-4 py-2 rounded-full hover:bg-gray-500 transition-colors">Mic Off</button>
                </div>
            </div>
        </div>

        <!-- Chat Section -->
        <div class="chat-container">
            <div id="chat-box" class="chat-box scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent">
                <!-- Chat messages will be dynamically added here -->
                <div class="text-center text-gray-400 py-2 text-sm">Welcome to your private watch party!</div>
            </div>
            <div class="input-area">
                <input id="message-input" type="text" placeholder="Send a message...">
                <button id="send-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l.68-1.425a1 1 0 10-1.875-.898L3.545 14.8l.68.226c.2.067.41-.01.526-.188L8 12.35l-3.264 4.566a1 1 0 00.99 1.579L12 17.5l-4-4-2.736 3.832a1 1 0 001.373 1.373L16 11.5l-2-2.828a1 1 0 00-.707-.293l-1.414-1.414a1 1 0 00-.707-.293L9.5 5.5l1.394-1.394z" />
                    </svg>
                </button>
            </div>
        </div>
        
    </div>
    
</body>
</html>
